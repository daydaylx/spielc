// supabase/functions/ai-content-generator/index.ts
// Das Magische Zauberbuch - AI Content Generation Edge Function
// Version: 1.0.0 - Production Ready

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};

interface AIRequest {
  prompt_name: string;
  parameters: Record<string, any>;
  story_id?: string;
  user_id: string;
}

interface AIResponse {
  content: string;
  tokens_used: number;
  processing_time: number;
  success: boolean;
  error?: string;
}

serve(async (req) => {
  // Handle CORS
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // Initialize Supabase client
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: { headers: { Authorization: req.headers.get('Authorization')! } },
      }
    );

    // Verify user authentication
    const { data: { user }, error: authError } = await supabaseClient.auth.getUser();
    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const { prompt_name, parameters, story_id, user_id }: AIRequest = await req.json();

    // Validate input
    if (!prompt_name || !parameters || !user_id || user_id !== user.id) {
      return new Response(
        JSON.stringify({ error: 'Invalid request parameters' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Check rate limiting
    const { data: recentRequests } = await supabaseClient
      .from('game_sessions')
      .select('id')
      .eq('user_id', user_id)
      .gte('start_time', new Date(Date.now() - 3600000).toISOString()) // Last hour
      .like('metadata->>action_type', '%ai_generation%');

    if (recentRequests && recentRequests.length > 50) {
      return new Response(
        JSON.stringify({ error: 'Rate limit exceeded. Please try again later.' }),
        { status: 429, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Fetch AI prompt template
    const { data: promptData, error: promptError } = await supabaseClient
      .from('ai_prompts')
      .select('*')
      .eq('name', prompt_name)
      .eq('is_active', true)
      .single();

    if (promptError || !promptData) {
      return new Response(
        JSON.stringify({ error: 'Prompt template not found' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Build prompt with parameters
    let finalPrompt = promptData.template;
    const mergedParams = { ...promptData.parameters, ...parameters };
    
    for (const [key, value] of Object.entries(mergedParams)) {
      const placeholder = `{${key}}`;
      finalPrompt = finalPrompt.replace(new RegExp(placeholder, 'g'), String(value));
    }

    // Call OpenRouter API
    const startTime = Date.now();
    
    const openRouterResponse = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${Deno.env.get('OPENROUTER_API_KEY')}`,
        'Content-Type': 'application/json',
        'X-Title': 'Das Magische Zauberbuch',
      },
      body: JSON.stringify({
        model: 'openai/gpt-4o',
        messages: [
          {
            role: 'system',
            content: 'Du bist ein kreativer Schreibassistent für ein interaktives Textadventure namens "Das Magische Zauberbuch". Erstelle fesselnde, immersive Inhalte auf Deutsch, die Spieler in eine magische Welt entführen. Verwende lebendige Beschreibungen und schaffe eine atmosphärische Stimmung.'
          },
          {
            role: 'user',
            content: finalPrompt
          }
        ],
        max_tokens: 1000,
        temperature: 0.8,
        presence_penalty: 0.1,
        frequency_penalty: 0.1
      }),
    });

    if (!openRouterResponse.ok) {
      throw new Error(`OpenRouter API error: ${openRouterResponse.status}`);
    }

    const aiResult = await openRouterResponse.json();
    const generatedContent = aiResult.choices[0]?.message?.content;
    const tokensUsed = aiResult.usage?.total_tokens || 0;
    const processingTime = Date.now() - startTime;

    if (!generatedContent) {
      throw new Error('No content generated by AI');
    }

    // Log the AI generation session
    await supabaseClient
      .from('game_sessions')
      .insert({
        user_id: user_id,
        story_id: story_id,
        session_data: {
          ai_generation: {
            prompt_name,
            parameters: mergedParams,
            content_length: generatedContent.length,
            tokens_used: tokensUsed,
            processing_time: processingTime
          }
        },
        start_time: new Date().toISOString(),
        end_time: new Date().toISOString(),
        duration_seconds: Math.round(processingTime / 1000),
        metadata: {
          action_type: 'ai_generation',
          prompt_category: promptData.category
        }
      });

    const response: AIResponse = {
      content: generatedContent,
      tokens_used: tokensUsed,
      processing_time: processingTime,
      success: true
    };

    return new Response(
      JSON.stringify(response),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('AI Generation Error:', error);
    
    return new Response(
      JSON.stringify({ 
        error: 'Internal server error', 
        success: false,
        details: error.message 
      }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});

// supabase/functions/story-processor/index.ts
// Das Magische Zauberbuch - Story Processing Edge Function
// Handles story validation, publishing, and complex operations

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

interface StoryProcessRequest {
  action: 'validate' | 'publish' | 'archive' | 'clone' | 'export';
  story_id: string;
  parameters?: Record<string, any>;
}

interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  statistics: {
    scenes: number;
    choices: number;
    characters: number;
    items: number;
    estimated_playtime: number;
  };
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: { headers: { Authorization: req.headers.get('Authorization')! } },
      }
    );

    const { data: { user }, error: authError } = await supabaseClient.auth.getUser();
    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const { action, story_id, parameters }: StoryProcessRequest = await req.json();

    // Verify story ownership or admin rights
    const { data: story, error: storyError } = await supabaseClient
      .from('stories')
      .select('*, user_profiles!inner(role)')
      .eq('id', story_id)
      .single();

    if (storyError || !story) {
      return new Response(
        JSON.stringify({ error: 'Story not found' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const isOwner = story.author_id === user.id;
    const isAdmin = story.user_profiles.role === 'admin' || story.user_profiles.role === 'moderator';

    if (!isOwner && !isAdmin) {
      return new Response(
        JSON.stringify({ error: 'Insufficient permissions' }),
        { status: 403, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    let result;

    switch (action) {
      case 'validate':
        result = await validateStory(supabaseClient, story_id);
        break;
      case 'publish':
        result = await publishStory(supabaseClient, story_id);
        break;
      case 'archive':
        result = await archiveStory(supabaseClient, story_id);
        break;
      case 'clone':
        result = await cloneStory(supabaseClient, story_id, user.id);
        break;
      case 'export':
        result = await exportStory(supabaseClient, story_id);
        break;
      default:
        throw new Error('Invalid action');
    }

    return new Response(
      JSON.stringify(result),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('Story Processing Error:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error', details: error.message }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});

async function validateStory(supabaseClient: any, storyId: string): Promise<ValidationResult> {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Get all story components
  const { data: scenes } = await supabaseClient
    .from('scenes')
    .select('*')
    .eq('story_id', storyId);

  const { data: choices } = await supabaseClient
    .from('choices')
    .select('*, scene:scenes(id, story_id)')
    .eq('scene.story_id', storyId);

  const { data: characters } = await supabaseClient
    .from('characters')
    .select('*')
    .eq('story_id', storyId);

  const { data: items } = await supabaseClient
    .from('items')
    .select('*')
    .eq('story_id', storyId);

  // Validate starting scene
  const startingScenes = scenes?.filter(s => s.is_starting_scene) || [];
  if (startingScenes.length === 0) {
    errors.push('Keine Startszene definiert');
  } else if (startingScenes.length > 1) {
    errors.push('Mehrere Startszenen definiert - nur eine erlaubt');
  }

  // Validate scene connectivity
  const sceneIds = new Set(scenes?.map(s => s.id) || []);
  const targetSceneIds = new Set(choices?.map(c => c.target_scene_id).filter(id => id) || []);
  
  for (const targetId of targetSceneIds) {
    if (!sceneIds.has(targetId)) {
      errors.push(`Verweis auf nicht existierende Szene: ${targetId}`);
    }
  }

  // Check for orphaned scenes
  const referencedScenes = new Set([
    ...startingScenes.map(s => s.id),
    ...Array.from(targetSceneIds)
  ]);
  
  const orphanedScenes = scenes?.filter(s => !referencedScenes.has(s.id)) || [];
  if (orphanedScenes.length > 0) {
    warnings.push(`${orphanedScenes.length} unerreichbare Szenen gefunden`);
  }

  // Validate scene content
  for (const scene of scenes || []) {
    if (!scene.content || scene.content.trim().length < 10) {
      errors.push(`Szene "${scene.title}" hat zu wenig Inhalt`);
    }
    
    if (scene.type === 'choice' && !choices?.some(c => c.scene_id === scene.id)) {
      warnings.push(`Wahlszene "${scene.title}" hat keine Auswahlmöglichkeiten`);
    }
  }

  // Calculate estimated playtime
  const averageReadingSpeed = 200; // words per minute
  const totalWords = scenes?.reduce((sum, scene) => {
    return sum + (scene.content?.split(' ').length || 0);
  }, 0) || 0;
  
  const estimatedPlaytime = Math.round(totalWords / averageReadingSpeed);

  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    statistics: {
      scenes: scenes?.length || 0,
      choices: choices?.length || 0,
      characters: characters?.length || 0,
      items: items?.length || 0,
      estimated_playtime: estimatedPlaytime
    }
  };
}

async function publishStory(supabaseClient: any, storyId: string) {
  // First validate the story
  const validation = await validateStory(supabaseClient, storyId);
  
  if (!validation.isValid) {
    return {
      success: false,
      error: 'Story validation failed',
      validation
    };
  }

  // Update story status and estimated playtime
  const { error } = await supabaseClient
    .from('stories')
    .update({
      status: 'published',
      published_at: new Date().toISOString(),
      estimated_playtime: validation.statistics.estimated_playtime
    })
    .eq('id', storyId);

  if (error) {
    throw error;
  }

  return {
    success: true,
    message: 'Story successfully published',
    validation
  };
}

async function archiveStory(supabaseClient: any, storyId: string) {
  const { error } = await supabaseClient
    .from('stories')
    .update({ status: 'archived' })
    .eq('id', storyId);

  if (error) {
    throw error;
  }

  return {
    success: true,
    message: 'Story archived successfully'
  };
}

async function cloneStory(supabaseClient: any, storyId: string, newAuthorId: string) {
  // Get original story with all components
  const { data: originalStory } = await supabaseClient
    .from('stories')
    .select(`
      *,
      scenes(*),
      characters(*),
      items(*)
    `)
    .eq('id', storyId)
    .single();

  if (!originalStory) {
    throw new Error('Original story not found');
  }

  // Create new story
  const newStoryId = crypto.randomUUID();
  const { error: storyError } = await supabaseClient
    .from('stories')
    .insert({
      id: newStoryId,
      title: `${originalStory.title} (Kopie)`,
      description: originalStory.description,
      author_id: newAuthorId,
      status: 'draft',
      difficulty: originalStory.difficulty,
      tags: originalStory.tags,
      metadata: originalStory.metadata,
      settings: originalStory.settings
    });

  if (storyError) {
    throw storyError;
  }

  // Clone scenes with ID mapping
  const sceneIdMap = new Map();
  for (const scene of originalStory.scenes) {
    const newSceneId = crypto.randomUUID();
    sceneIdMap.set(scene.id, newSceneId);
    
    await supabaseClient
      .from('scenes')
      .insert({
        id: newSceneId,
        story_id: newStoryId,
        title: scene.title,
        content: scene.content,
        type: scene.type,
        order_index: scene.order_index,
        is_starting_scene: scene.is_starting_scene,
        is_ending_scene: scene.is_ending_scene,
        conditions: scene.conditions,
        effects: scene.effects,
        metadata: scene.metadata,
        background_image_url: scene.background_image_url,
        background_music_url: scene.background_music_url
      });
  }

  // Clone choices with updated scene references
  const { data: originalChoices } = await supabaseClient
    .from('choices')
    .select('*')
    .in('scene_id', originalStory.scenes.map(s => s.id));

  for (const choice of originalChoices || []) {
    await supabaseClient
      .from('choices')
      .insert({
        scene_id: sceneIdMap.get(choice.scene_id),
        text: choice.text,
        target_scene_id: choice.target_scene_id ? sceneIdMap.get(choice.target_scene_id) : null,
        type: choice.type,
        order_index: choice.order_index,
        conditions: choice.conditions,
        effects: choice.effects,
        metadata: choice.metadata,
        is_available: choice.is_available
      });
  }

  // Clone characters
  for (const character of originalStory.characters) {
    await supabaseClient
      .from('characters')
      .insert({
        story_id: newStoryId,
        name: character.name,
        description: character.description,
        avatar_url: character.avatar_url,
        personality: character.personality,
        stats: character.stats,
        dialogue_style: character.dialogue_style,
        relationships: character.relationships,
        is_active: character.is_active
      });
  }

  // Clone items
  for (const item of originalStory.items) {
    await supabaseClient
      .from('items')
      .insert({
        story_id: newStoryId,
        name: item.name,
        description: item.description,
        type: item.type,
        rarity: item.rarity,
        value: item.value,
        stackable: item.stackable,
        max_stack: item.max_stack,
        properties: item.properties,
        image_url: item.image_url,
        is_active: item.is_active
      });
  }

  return {
    success: true,
    message: 'Story cloned successfully',
    new_story_id: newStoryId
  };
}

async function exportStory(supabaseClient: any, storyId: string) {
  const { data: storyData } = await supabaseClient
    .from('stories')
    .select(`
      *,
      scenes(*),
      characters(*),
      items(*),
      choices(*)
    `)
    .eq('id', storyId)
    .single();

  if (!storyData) {
    throw new Error('Story not found');
  }

  // Remove sensitive data
  delete storyData.author_id;
  delete storyData.created_at;
  delete storyData.updated_at;

  const exportData = {
    format_version: '1.0.0',
    export_date: new Date().toISOString(),
    story: storyData
  };

  return {
    success: true,
    data: exportData,
    filename: `${storyData.title.replace(/[^a-zA-Z0-9]/g, '_')}_export.json`
  };
}

// supabase/functions/user-management/index.ts
// Das Magische Zauberbuch - User Management Edge Function

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

interface UserManagementRequest {
  action: 'update_profile' | 'get_statistics' | 'update_preferences' | 'delete_account';
  data?: any;
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { data: { user }, error: authError } = await supabaseClient.auth.getUser(
      req.headers.get('Authorization')?.replace('Bearer ', '') ?? ''
    );

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const { action, data }: UserManagementRequest = await req.json();

    let result;

    switch (action) {
      case 'update_profile':
        result = await updateUserProfile(supabaseClient, user.id, data);
        break;
      case 'get_statistics':
        result = await getUserStatistics(supabaseClient, user.id);
        break;
      case 'update_preferences':
        result = await updateUserPreferences(supabaseClient, user.id, data);
        break;
      case 'delete_account':
        result = await deleteUserAccount(supabaseClient, user.id);
        break;
      default:
        throw new Error('Invalid action');
    }

    return new Response(
      JSON.stringify(result),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('User Management Error:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error', details: error.message }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});

async function updateUserProfile(supabaseClient: any, userId: string, profileData: any) {
  const { error } = await supabaseClient
    .from('user_profiles')
    .update({
      display_name: profileData.display_name,
      avatar_url: profileData.avatar_url,
      last_login: new Date().toISOString()
    })
    .eq('id', userId);

  if (error) {
    throw error;
  }

  return { success: true, message: 'Profile updated successfully' };
}

async function getUserStatistics(supabaseClient: any, userId: string) {
  // Get comprehensive user statistics
  const { data: sessions } = await supabaseClient
    .from('game_sessions')
    .select('*')
    .eq('user_id', userId);

  const { data: achievements } = await supabaseClient
    .from('user_achievements')
    .select('*, achievement:achievements(*)')
    .eq('user_id', userId);

  const { data: stories } = await supabaseClient
    .from('stories')
    .select('id, title, status, created_at')
    .eq('author_id', userId);

  const { data: ratings } = await supabaseClient
    .from('story_ratings')
    .select('rating, story:stories(title)')
    .eq('user_id', userId);

  const totalPlaytime = sessions?.reduce((sum, session) => sum + (session.duration_seconds || 0), 0) || 0;
  const averageRating = ratings?.length ? 
    ratings.reduce((sum, r) => sum + r.rating, 0) / ratings.length : 0;

  return {
    success: true,
    statistics: {
      total_playtime: totalPlaytime,
      total_sessions: sessions?.length || 0,
      total_achievements: achievements?.length || 0,
      stories_created: stories?.length || 0,
      stories_published: stories?.filter(s => s.status === 'published').length || 0,
      average_rating_given: Math.round(averageRating * 10) / 10,
      total_ratings_given: ratings?.length || 0,
      most_played_stories: await getMostPlayedStories(supabaseClient, userId),
      recent_achievements: achievements?.slice(-5) || []
    }
  };
}

async function getMostPlayedStories(supabaseClient: any, userId: string) {
  const { data } = await supabaseClient
    .from('game_sessions')
    .select('story_id, story:stories(title), duration_seconds')
    .eq('user_id', userId)
    .not('story_id', 'is', null);

  const storyPlaytime = data?.reduce((acc, session) => {
    const storyId = session.story_id;
    acc[storyId] = (acc[storyId] || 0) + (session.duration_seconds || 0);
    return acc;
  }, {}) || {};

  return Object.entries(storyPlaytime)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 5)
    .map(([storyId, playtime]) => ({
      story_id: storyId,
      playtime: playtime,
      story_title: data?.find(d => d.story_id === storyId)?.story?.title || 'Unknown'
    }));
}

async function updateUserPreferences(supabaseClient: any, userId: string, preferences: any) {
  const { error } = await supabaseClient
    .from('user_settings')
    .upsert({
      user_id: userId,
      settings: preferences
    });

  if (error) {
    throw error;
  }

  return { success: true, message: 'Preferences updated successfully' };
}

async function deleteUserAccount(supabaseClient: any, userId: string) {
  // Note: This is a soft delete that anonymizes data
  // Actual user deletion would be handled by Supabase Auth
  
  const { error } = await supabaseClient
    .from('user_profiles')
    .update({
      username: `deleted_user_${Date.now()}`,
      display_name: 'Deleted User',
      avatar_url: null,
      is_active: false
    })
    .eq('id', userId);

  if (error) {
    throw error;
  }

  return { success: true, message: 'Account deactivated successfully' };
}